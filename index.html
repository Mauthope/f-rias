<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Detecção de Movimento</title>
    <script src="https://docs.opencv.org/4.x/opencv.js" defer></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
        }
        video, canvas {
            max-width: 100%;
            margin: 10px auto;
        }
        table {
            margin: 10px auto;
            border-collapse: collapse;
            width: 80%;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        th {
            background-color: #f4f4f4;
        }
    </style>
</head>
<body>
    <h1>Detecção de Movimento</h1>
    <video id="video" autoplay playsinline></video>
    <canvas id="canvas" style="display: none;"></canvas>
    <table>
        <thead>
            <tr>
                <th>Data</th>
                <th>Hora</th>
                <th>Evento</th>
            </tr>
        </thead>
        <tbody id="log"></tbody>
    </table>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const log = document.getElementById('log');

        // Solicita acesso à câmera
        navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } })
            .then(stream => {
                video.srcObject = stream;
            })
            .catch(err => console.error('Erro ao acessar a câmera:', err));

        video.addEventListener('play', () => {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;

            const src = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
            const gray = new cv.Mat();
            const prevGray = new cv.Mat();
            const diff = new cv.Mat();
            const thresh = new cv.Mat();

            let firstFrame = true;
            const movimentoThreshold = 5000; // Ajuste conforme necessário

            function processFrame() {
                if (video.paused || video.ended) {
                    src.delete();
                    gray.delete();
                    prevGray.delete();
                    diff.delete();
                    thresh.delete();
                    return;
                }

                // Captura o frame atual
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                src.data.set(imageData.data);

                // Converte para escala de cinza
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

                if (firstFrame) {
                    gray.copyTo(prevGray);
                    firstFrame = false;
                    requestAnimationFrame(processFrame);
                    return;
                }

                // Calcula a diferença absoluta entre o frame atual e o anterior
                cv.absdiff(gray, prevGray, diff);

                // Aplica um limiar para destacar as áreas de movimento
                cv.threshold(diff, thresh, 25, 255, cv.THRESH_BINARY);

                // Aplica dilatação para preencher buracos nas áreas detectadas
                let kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(5, 5));
                cv.dilate(thresh, thresh, kernel, new cv.Point(-1, -1), 2, cv.BORDER_CONSTANT, cv.morphologyDefaultBorderValue());

                // Conta o número de pixels em movimento
                const movimento = cv.countNonZero(thresh);
                console.log(`Pixels em movimento: ${movimento}`);

                // Define se houve movimento com base no threshold
                if (movimento > movimentoThreshold) {
                    const now = new Date();
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${now.toLocaleDateString()}</td>
                        <td>${now.toLocaleTimeString()}</td>
                        <td>Movimento Detectado</td>
                    `;
                    log.appendChild(row);
                }

                // Atualiza o frame anterior
                gray.copyTo(prevGray);

                requestAnimationFrame(processFrame);
            }

            processFrame();
        });
    </script>
</body>
</html>
